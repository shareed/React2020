#### [Client-Side Authentication Lecture](https://www.youtube.com/watch?v=iFUwQgZq85E&feature=youtu.be)

*In general, servers don’t remember anything about us after each interaction. Clients need to tack a reminder to every request, and this is commonly done automatically with cookies. Cookies are just small pieces of data generated by the browser to store state information.*

*Modern web services dealing with JSON data often use Json Web Tokens (JWT)s instead. These tokens, issued by the server, are strings of cryptic text, which can be stored on the client-side using local storage or session storage. The server can readily tell the client that it issued the token. It can also read the token and make decisions for data transfer based on the client’s permission.*

*A common pattern is for a login endpoint to exist, which takes a payload of username and password. If the credentials are known, the server responds with a fresh JWT. From then on, it’s the application’s responsibility to add an Authorization: <token> header to every request, to be allowed access to protected resources that require authentication.*
* Handle authentication with tokens in a React app
* Implement protected routes using an authentication token and Redirect
* headers are meata dat about the request






* Any request to an API will have a Response and Request Headers
* we can add authentication header to our request header that we can use to pass a token to a server
* a get request that adds a token to the authorization request header
* Some API’s require you to use a slightly different syntax. Make sure you understand the API you are working with

## JSON Web Tokens and Auth
Visuals first :) here's what we're learning about today:

![JWT Auth Flow](src/img/auth_flow.png)

Thanks Mark Macneil for this diagram! In our case, there's just one server (rather than separate auth and database servers) but the concept is the same. Here's a typical auth flow, in words:
1. Client app (our front-end React app, running "client-side" in the browser) makes a request to the login endpoint on a web server, sending username and password
2. If successful, the server responds with a token, which the client app saves locally in the browser (localStorage, cookies, etc)
3. When making a request to a "protected" (login required) endpoint, our client app includes this token as an authorization header for every axios request.

Some version of this pattern is used in virtually every web application and mobile app in existence today. If you've ever wondered how you're able to "stay logged in" to websites and mobile apps (all of which consume external API's), this is the answer. And more specifically, this is all achieved using JSON Web Tokens. 

For our purposes, we can simply think of a JSON web token (or JWT for short, pronounced “jot”) as a credential format, used for transferring information securely between a client app and a web server. Check out [jwt.io](https://jwt.io/) for more info if you're curious about the specifics.

## Review: Local Storage
For your Auth Friends project, you'll be using an auth token to make requests to protected API endpoints. After initial authentication, saving the returned auth token locally is a common practice for allowing the user to remain "logged in." We'll use Local Storage for this, since it provides a very straightforward way of saving key/value pairs locally in the browser. Here's a quick review:

```javascript
localStorage.setItem('key', 'value');
localStorage.getItem('key'); // returns 'value
```

Along with `localStorage.removeItem` and `localStorage.clear()` for cleanup, that's basically the entire API! Nice and simple. Note that there are other, more secure methods of saving JWT auth tokens locally and `localStorage` is rarely a good choice for storing auth tokens in production applications. The functionality is pretty similar though, so the localStorage approach provides a good introduction for learning client-side auth.

## API review: HTTP and RESTful services
Since you'll also be working directly with an API for the Auth Friends project, here's a quick review / cheat sheet for how to interact with web services. Most modern API's conform to the "representational state transfer" (REST) architecture.

| HTTP Verb (axios) | CRUD naming      | Description                         | Happy Path                   |
|-------------------|------------------|-------------------------------------|------------------------------|
| get               | Read             | Read a representation of a resource | 200 (OK)                     |
| post              | Create           | Create new resources                | 201 (created)                |
| put               | Update           | Update a resource                   | 200 (OK) or 201 (created)    |
| delete            | Delete           | Delete a resource                   | 200 (OK) or 204 (no content) |

To make debugging easier as you're building out your web client, log any errors to the console from your axios requests. You can always just Google the error codes and messages that show up, but knowing the common ones will make your life a lot easier! Here are some good ones to know:

* **400 Bad Request:** you sent an invalid JSON document (e.g. a "}" is missing), or the syntax/content is incorrect.

* **401 Unauthorized:** the access credentials (via the Authorization header) were missing or are invalid.

* **403 Forbidden:** the credentials you provided are valid, but you are not authorized to access the resource you requested.

* **404 Not found:** the request itself is valid, but the resource you try to access does not exist, or is outside your scope.


## Videos
* [Protected Routes in React using React Router](https://www.youtube.com/watch?v=Y0-qdp-XBJg)
* [React Client Side Authentication](https://www.youtube.com/watch?v=oRL-pttfNSc)

## Articles
* [Introduction to JSON Web Tokens](https://jwt.io/introduction/)
* [Protected Routes - React tutorial](https://medium.com/javascript-in-plain-english/how-to-set-up-protected-routes-in-your-react-application-a3254deda380)
* [Building Basic React Authentication](https://medium.com/better-programming/building-basic-react-authentication-e20a574d5e71)
* [Introduction to Local Storage](https://sebhastian.com/local-storage-introduction)
* [HTTP Verbs and Error Codes](https://developers.evrythng.com/docs/http-verbs-and-error-codes)

### Private Routes

1.  has the same API as <Route />, the component can accept a component Prop, just like <Route /> does, and take any other prop that gets passed into it by spreading in ...rest.
  * `const PrivateRoute = ({ component: Component, ...rest }) => ()`
2.  renders a <Route /> and passes all the props through to <PrivateRoute /> in the App component.
  * `const PrivateRoute = ({ component: Component, ...rest }) => (<Route {...rest} render={} />)`

3.  checks if the user is authenticated, if they are, it renders the “component” prop. If not, it redirects the user to /login.

            const PrivateRoute = ({ component: Component, ...rest }) => (
              <Route
                {...rest}
                render={props =>
                  localStorage.getItem("token") ? (
                    <Component {...props} />
                  ) : (
                    <Redirect to="/login" />
                  )
                }
              />
            );


            * This is using the render props pattern. We won’t go too much into how this works here, but it would be a great weekend learning objective for you to look into if you so desire.

            * <Redirect /> component is from React Router. It does exactly what you think - redirects the app to the supplied route.

**Private Route Component** 

        import React from 'react';
      import { Route, Redirect } from 'react-router-dom';

      /*
        Private Route rules:
        1. It has the same API as <Route />.
        2. It renders a <Route /> and passes all the props through to it.
        3. It checks if the user is authenticated, if they are, it renders the “component” prop. If not, it redirects the user to /login.
      */

      // rest operator (looks a lot like spread operator)
      const PrivateRoute = ({ component: Component, ...rest }) => {
        // const Component = component;
        const token = window.localStorage.getItem('token');
        return (
          <Route
            {...rest}
            render={props => {
              if (token) {
                // return the component
                return <Component {...props} />;
              } else {
                // redirect the user to /login
                return <Redirect to="/login" />;
              }
            }}
          />
        );
      };

      export default PrivateRoute;
* instead of wrapping the component in Route wrap in in the Private Route Component
  * `<PrivateRoute exact path="/protected" component={GasPrices} />`






#### GET REQUEST

    getData = () => {
        // get request
        axios
          .get('http://localhost:5000/api/data')
          .then(res => console.log(res))
          .catch(err => console.log(err));
    };

### ADD TOKEN TO REQUEST HEADER
* every axios call can take a second argument which is an object to configure things for that call
        
      getData = () => {
          // add the token to the authorization header
          const token = window.localStorage.getItem('token');
          axios
            .get('http://localhost:5000/api/data', {
              headers: {
                authorization: token
              }
            })
            .then(res => console.log("Response:", res))
            .catch(err => console.log(err));
      };


#### Refactor to make reuseable
* axiosWithAuth.js

      import axios from 'axios';

      export const axiosWithAuth = () => {
        // get the token from localstorage
        const token = window.localStorage.getItem('token');
        // create a new "instance" of axios with the config object built into it
        return axios.create({
          headers: {
            authorization: token
          },
          baseURL: 'http://localhost:5000'
        });
      };


#### [PUT REQUEST](./src/img/put.jpg)
* PUT is the “U” in CRUD, and it stands for UPDATE. We use the PUT method to change a resource’s information. PUT takes in a body object like POST and identifies data that needs to be updated somewhere.